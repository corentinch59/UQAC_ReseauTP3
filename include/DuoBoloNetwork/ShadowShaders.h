//
// Created by theo on 11/03/2025.
//

#pragma once

inline const char* gShadowShaderVertex =
"#version 330\n"
"\n"
"in vec3 vertexPosition;\n"
"in vec2 vertexTexCoord;\n"
"in vec3 vertexNormal;\n"
"in vec4 vertexColor;\n"
"\n"
"uniform mat4 mvp;\n"
"uniform mat4 matModel;\n"
"uniform mat4 matNormal;\n"
"\n"
"out vec3 fragPosition;\n"
"out vec2 fragTexCoord;\n"
"out vec4 fragColor;\n"
"out vec3 fragNormal;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    fragPosition = vec3(matModel*vec4(vertexPosition, 1.0));\n"
"    fragTexCoord = vertexTexCoord;\n"
"    fragColor = vertexColor;\n"
"    fragNormal = normalize(vec3(matNormal*vec4(vertexNormal, 1.0)));\n"
"\n"
"    gl_Position = mvp*vec4(vertexPosition, 1.0);\n"
"}\n";

inline const char* gShadowShaderFragment =
"#version 330\n"
"\n"
"in vec3 fragPosition;\n"
"in vec2 fragTexCoord;\n"
"in vec3 fragNormal;\n"
"\n"
"uniform sampler2D texture0;\n"
"uniform vec4 colDiffuse;\n"
"\n"
"out vec4 finalColor;\n"
"\n"
"uniform vec3 lightDir;\n"
"uniform vec4 lightColor;\n"
"uniform vec4 ambient;\n"
"uniform vec3 viewPos;\n"
"\n"
"uniform mat4 lightVP;\n"
"uniform sampler2D shadowMap;\n"
"\n"
"uniform int shadowMapResolution;\n"
"\n"
"void main()\n"
"{\n"
"    vec4 texelColor = texture(texture0, fragTexCoord);\n"
"    vec3 lightDot = vec3(0.0);\n"
"    vec3 normal = normalize(fragNormal);\n"
"    vec3 viewD = normalize(viewPos - fragPosition);\n"
"    vec3 specular = vec3(0.0);\n"
"\n"
"    vec3 l = -lightDir;\n"
"\n"
"    float NdotL = max(dot(normal, l), 0.0);\n"
"    lightDot += lightColor.rgb*NdotL;\n"
"\n"
"    float specCo = 0.0;\n"
"    if (NdotL > 0.0) specCo = pow(max(0.0, dot(viewD, reflect(-(l), normal))), 16.0); // 16 refers to shine\n"
"    specular += specCo;\n"
"\n"
"    finalColor = (texelColor*((colDiffuse + vec4(specular, 1.0))*vec4(lightDot, 1.0)));\n"
"\n"
"    vec4 fragPosLightSpace = lightVP * vec4(fragPosition, 1);\n"
"    fragPosLightSpace.xyz /= fragPosLightSpace.w; // Perform the perspective division\n"
"    fragPosLightSpace.xyz = (fragPosLightSpace.xyz + 1.0)/2.0; // Transform from [-1, 1] range to [0, 1] range\n"
"    vec2 sampleCoords = fragPosLightSpace.xy;\n"
"    float curDepth = fragPosLightSpace.z;\n"
"\n"
"    float bias = max(0.0002*(1.0 - dot(normal, l)), 0.00002) + 0.00001;\n"
"    int shadowCounter = 0;\n"
"    const int numSamples = 9;\n"
"\n"
"    vec2 texelSize = vec2(1.0/float(shadowMapResolution));\n"
"    for (int x = -1; x <= 1; x++)\n"
"    {\n"
"        for (int y = -1; y <= 1; y++)\n"
"        {\n"
"            float sampleDepth = texture(shadowMap, sampleCoords + texelSize*vec2(x, y)).r;\n"
"            if (curDepth - bias > sampleDepth) shadowCounter++;\n"
"        }\n"
"    }\n"
"    finalColor = mix(finalColor, vec4(0, 0, 0, 1), float(shadowCounter)/float(numSamples));\n"
"\n"
"    finalColor += texelColor*(ambient/10.0)*colDiffuse;\n"
"\n"
"    finalColor = pow(finalColor, vec4(1.0/2.2));\n"
"}\n";